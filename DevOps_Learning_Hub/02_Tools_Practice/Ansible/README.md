# Ansible - Configuration Management & Automation

## Overview
Ansible is an agentless automation platform that can configure systems, deploy software, and orchestrate advanced IT tasks such as continuous deployments or zero downtime rolling updates.

## Learning Objectives
- Master Ansible fundamentals (playbooks, roles, modules)
- Implement infrastructure as code with Ansible
- Automate configuration management across multiple environments
- Integrate Ansible with CI/CD pipelines
- Manage secrets and security with Ansible Vault
- Scale Ansible for enterprise environments

## Prerequisites
- Basic Linux/Unix knowledge
- Understanding of YAML syntax
- SSH access to target machines
- Python installed on control node

---

## Lab 1: Ansible Installation and Basic Setup

### Objective
Install Ansible and configure basic inventory management.

### Steps

1. **Install Ansible**
```bash
# Ubuntu/Debian
sudo apt update
sudo apt install ansible

# CentOS/RHEL
sudo yum install epel-release
sudo yum install ansible

# macOS
brew install ansible

# Windows (WSL or use control machine)
pip install ansible
```

2. **Create Basic Inventory**
```ini
# inventory.ini
[webservers]
web1 ansible_host=192.168.1.10 ansible_user=ubuntu
web2 ansible_host=192.168.1.11 ansible_user=ubuntu

[databases]
db1 ansible_host=192.168.1.20 ansible_user=ubuntu

[all:vars]
ansible_ssh_private_key_file=~/.ssh/id_rsa
```

3. **Test Connectivity**
```bash
ansible all -i inventory.ini -m ping
ansible webservers -i inventory.ini -m setup
```

### Exercise
- Set up Ansible on your control machine
- Create inventory for 3 test servers
- Verify connectivity using ping module

---

## Lab 2: Writing Your First Playbook

### Objective
Create and execute basic Ansible playbooks for system configuration.

### Steps

1. **Create Simple Playbook**
```yaml
# first-playbook.yml
---
- name: Configure web servers
  hosts: webservers
  become: yes
  tasks:
    - name: Update package cache
      apt:
        update_cache: yes
      when: ansible_os_family == "Debian"
    
    - name: Install Nginx
      package:
        name: nginx
        state: present
    
    - name: Start and enable Nginx
      service:
        name: nginx
        state: started
        enabled: yes
    
    - name: Create custom index page
      copy:
        content: |
          <html>
          <head><title>Ansible Managed Server</title></head>
          <body>
            <h1>Welcome to {{ inventory_hostname }}</h1>
            <p>Managed by Ansible</p>
          </body>
          </html>
        dest: /var/www/html/index.html
        mode: '0644'
```

2. **Execute Playbook**
```bash
ansible-playbook -i inventory.ini first-playbook.yml
ansible-playbook -i inventory.ini first-playbook.yml --check --diff
```

### Exercise
- Create a playbook to install and configure Apache
- Add handlers for service restart
- Use templates for configuration files

---

## Lab 3: Working with Variables and Facts

### Objective
Master Ansible variables, facts, and conditional logic.

### Steps

1. **Group Variables**
```yaml
# group_vars/webservers.yml
nginx_user: www-data
nginx_port: 80
custom_packages:
  - git
  - curl
  - htop

# group_vars/databases.yml
mysql_root_password: "{{ vault_mysql_password }}"
mysql_databases:
  - name: webapp
    charset: utf8mb4
```

2. **Host Variables**
```yaml
# host_vars/web1.yml
server_role: primary
backup_enabled: true

# host_vars/web2.yml
server_role: secondary
backup_enabled: false
```

3. **Advanced Playbook with Variables**
```yaml
# variables-demo.yml
---
- name: Demonstrate variables and facts
  hosts: all
  gather_facts: yes
  vars:
    common_packages:
      - vim
      - wget
      - unzip
  
  tasks:
    - name: Display system information
      debug:
        msg: |
          Hostname: {{ ansible_hostname }}
          OS: {{ ansible_distribution }} {{ ansible_distribution_version }}
          Architecture: {{ ansible_architecture }}
          Memory: {{ ansible_memtotal_mb }}MB
    
    - name: Install common packages
      package:
        name: "{{ common_packages }}"
        state: present
      become: yes
    
    - name: Configure based on role
      template:
        src: server-config.j2
        dest: /etc/server-role.conf
      when: server_role is defined
      become: yes
```

4. **Jinja2 Template**
```jinja2
# templates/server-config.j2
# Server Configuration
# Generated by Ansible on {{ ansible_date_time.date }}

SERVER_ROLE={{ server_role | default('unknown') }}
SERVER_NAME={{ inventory_hostname }}
ENVIRONMENT={{ env | default('development') }}

{% if ansible_distribution == "Ubuntu" %}
PACKAGE_MANAGER=apt
{% elif ansible_distribution == "CentOS" %}
PACKAGE_MANAGER=yum
{% endif %}

{% if backup_enabled | default(false) %}
BACKUP_ENABLED=true
BACKUP_TIME=02:00
{% endif %}
```

### Exercise
- Create variable files for different environments
- Use custom facts in playbooks
- Implement conditional task execution

---

## Lab 4: Ansible Roles and Galaxy

### Objective
Create reusable Ansible roles and use Ansible Galaxy.

### Steps

1. **Create Role Structure**
```bash
ansible-galaxy init nginx-role
cd nginx-role
```

2. **Role Tasks**
```yaml
# tasks/main.yml
---
- name: Install Nginx
  package:
    name: nginx
    state: present
  become: yes

- name: Configure Nginx
  template:
    src: nginx.conf.j2
    dest: /etc/nginx/nginx.conf
    backup: yes
  become: yes
  notify: restart nginx

- name: Create document root
  file:
    path: "{{ nginx_document_root }}"
    state: directory
    owner: "{{ nginx_user }}"
    group: "{{ nginx_group }}"
    mode: '0755'
  become: yes

- name: Deploy website content
  template:
    src: index.html.j2
    dest: "{{ nginx_document_root }}/index.html"
    owner: "{{ nginx_user }}"
    group: "{{ nginx_group }}"
    mode: '0644'
  become: yes
```

3. **Role Defaults**
```yaml
# defaults/main.yml
---
nginx_user: www-data
nginx_group: www-data
nginx_port: 80
nginx_document_root: /var/www/html
nginx_server_name: "{{ ansible_fqdn }}"
```

4. **Role Handlers**
```yaml
# handlers/main.yml
---
- name: restart nginx
  service:
    name: nginx
    state: restarted
  become: yes

- name: reload nginx
  service:
    name: nginx
    state: reloaded
  become: yes
```

5. **Using Roles in Playbooks**
```yaml
# site.yml
---
- name: Configure web infrastructure
  hosts: webservers
  roles:
    - role: nginx-role
      nginx_port: 8080
      nginx_server_name: myapp.local
    
    - role: geerlingguy.mysql
      vars:
        mysql_root_password: supersecret
```

### Exercise
- Create roles for MySQL, Redis, and monitoring
- Use Ansible Galaxy to install community roles
- Implement role dependencies

---

## Lab 5: Ansible Vault for Secrets Management

### Objective
Secure sensitive data using Ansible Vault.

### Steps

1. **Create Encrypted Variables**
```bash
# Create vault file
ansible-vault create group_vars/all/vault.yml

# Edit vault file
ansible-vault edit group_vars/all/vault.yml

# View vault file
ansible-vault view group_vars/all/vault.yml
```

2. **Vault Content**
```yaml
# group_vars/all/vault.yml (encrypted)
vault_mysql_root_password: supersecretpassword
vault_api_key: abc123xyz789
vault_ssl_cert: |
  -----BEGIN CERTIFICATE-----
  MIIDXTCCAkWgAwIBAgIJAL...
  -----END CERTIFICATE-----
```

3. **Reference Vault Variables**
```yaml
# group_vars/all/vars.yml (unencrypted)
mysql_root_password: "{{ vault_mysql_root_password }}"
api_key: "{{ vault_api_key }}"
ssl_certificate: "{{ vault_ssl_cert }}"
```

4. **Run with Vault**
```bash
# Prompt for password
ansible-playbook -i inventory.ini site.yml --ask-vault-pass

# Use password file
echo "mypassword" > .vault_pass
ansible-playbook -i inventory.ini site.yml --vault-password-file .vault_pass
```

### Exercise
- Encrypt database passwords and API keys
- Create separate vault files for different environments
- Integrate vault with CI/CD pipelines

---

## Lab 6: Advanced Ansible Patterns

### Objective
Implement advanced Ansible patterns for complex deployments.

### Steps

1. **Rolling Updates**
```yaml
# rolling-update.yml
---
- name: Rolling update web servers
  hosts: webservers
  serial: 1
  max_fail_percentage: 0
  
  pre_tasks:
    - name: Remove from load balancer
      uri:
        url: "http://{{ load_balancer }}/api/servers/{{ inventory_hostname }}/disable"
        method: POST
      delegate_to: localhost
  
  tasks:
    - name: Update application
      git:
        repo: "{{ app_repository }}"
        dest: "{{ app_directory }}"
        version: "{{ app_version }}"
      notify: restart application
    
    - name: Install dependencies
      pip:
        requirements: "{{ app_directory }}/requirements.txt"
        virtualenv: "{{ app_directory }}/venv"
  
  post_tasks:
    - name: Wait for application to start
      wait_for:
        port: "{{ app_port }}"
        timeout: 60
    
    - name: Add back to load balancer
      uri:
        url: "http://{{ load_balancer }}/api/servers/{{ inventory_hostname }}/enable"
        method: POST
      delegate_to: localhost
  
  handlers:
    - name: restart application
      systemd:
        name: myapp
        state: restarted
```

2. **Blue-Green Deployment**
```yaml
# blue-green.yml
---
- name: Blue-Green Deployment
  hosts: localhost
  vars:
    current_color: "{{ hostvars[groups['webservers'][0]]['deployment_color'] | default('blue') }}"
    new_color: "{{ 'green' if current_color == 'blue' else 'blue' }}"
  
  tasks:
    - name: Deploy to {{ new_color }} environment
      include_tasks: deploy-app.yml
      vars:
        target_group: "{{ new_color }}_servers"
        deployment_color: "{{ new_color }}"
    
    - name: Run health checks
      uri:
        url: "http://{{ item }}:{{ app_port }}/health"
      loop: "{{ groups[new_color + '_servers'] }}"
    
    - name: Switch traffic to {{ new_color }}
      template:
        src: nginx-upstream.j2
        dest: /etc/nginx/conf.d/upstream.conf
      delegate_to: "{{ item }}"
      loop: "{{ groups['load_balancers'] }}"
      notify: reload nginx
    
    - name: Update deployment color fact
      set_fact:
        deployment_color: "{{ new_color }}"
      delegate_to: "{{ item }}"
      delegate_facts: yes
      loop: "{{ groups['webservers'] }}"
```

### Exercise
- Implement canary deployments
- Create maintenance mode playbooks
- Build disaster recovery automation

---

## Lab 7: Ansible with Dynamic Inventory

### Objective
Use dynamic inventory with cloud providers and automation.

### Steps

1. **AWS Dynamic Inventory**
```yaml
# aws_ec2.yml
plugin: amazon.aws.aws_ec2
regions:
  - us-east-1
  - us-west-2
keyed_groups:
  - key: tags
    prefix: tag
  - key: instance_type
    prefix: type
  - key: placement.region
    prefix: aws_region
hostnames:
  - dns-name
  - private-ip-address
filters:
  instance-state-name: running
```

2. **Azure Dynamic Inventory**
```yaml
# azure_rm.yml
plugin: azure.azcollection.azure_rm
include_vm_resource_groups:
  - myresourcegroup
auth_source: auto
keyed_groups:
  - key: tags
    prefix: tag
  - key: location
    prefix: azure_loc
  - key: powerstate
    prefix: power
```

3. **Custom Dynamic Inventory Script**
```python
#!/usr/bin/env python3
# custom-inventory.py
import json
import requests

def get_inventory():
    # Fetch inventory from CMDB/API
    response = requests.get('https://api.example.com/servers')
    servers = response.json()
    
    inventory = {
        '_meta': {
            'hostvars': {}
        }
    }
    
    for server in servers:
        group = server['environment']
        if group not in inventory:
            inventory[group] = {'hosts': []}
        
        inventory[group]['hosts'].append(server['hostname'])
        inventory['_meta']['hostvars'][server['hostname']] = {
            'ansible_host': server['ip_address'],
            'server_role': server['role'],
            'environment': server['environment']
        }
    
    return inventory

if __name__ == '__main__':
    print(json.dumps(get_inventory(), indent=2))
```

### Exercise
- Configure dynamic inventory for your cloud provider
- Create custom inventory scripts for your infrastructure
- Implement inventory caching for performance

---

## Lab 8: Ansible Testing and Validation

### Objective
Implement testing strategies for Ansible playbooks and roles.

### Steps

1. **Molecule Testing Setup**
```bash
pip install molecule[docker]
cd nginx-role
molecule init scenario
```

2. **Molecule Configuration**
```yaml
# molecule/default/molecule.yml
---
dependency:
  name: galaxy
driver:
  name: docker
platforms:
  - name: instance
    image: ubuntu:20.04
    pre_build_image: true
    command: /lib/systemd/systemd
    cgroupns_mode: host
    privileged: true
    volumes:
      - /sys/fs/cgroup:/sys/fs/cgroup:rw
provisioner:
  name: ansible
  config_options:
    defaults:
      interpreter_python: auto_silent
      callback_whitelist: profile_tasks, timer, yaml
    ssh_connection:
      pipelining: false
verifier:
  name: ansible
```

3. **Test Playbook**
```yaml
# molecule/default/converge.yml
---
- name: Converge
  hosts: all
  become: true
  tasks:
    - name: "Include nginx-role"
      include_role:
        name: "nginx-role"
```

4. **Verification Tests**
```yaml
# molecule/default/verify.yml
---
- name: Verify
  hosts: all
  gather_facts: false
  tasks:
    - name: Check nginx is running
      service:
        name: nginx
        state: started
      check_mode: yes
      register: nginx_status
      failed_when: nginx_status.changed
    
    - name: Test nginx response
      uri:
        url: http://localhost
        return_content: yes
      register: response
      failed_when: "'Welcome' not in response.content"
```

5. **Run Tests**
```bash
molecule test
molecule converge
molecule verify
```

### Exercise
- Create comprehensive test suites for your roles
- Implement integration tests with multiple services
- Set up CI/CD pipeline for Ansible testing

---

## Lab 9: Ansible in CI/CD Pipelines

### Objective
Integrate Ansible with CI/CD pipelines for automated deployments.

### Steps

1. **GitLab CI Integration**
```yaml
# .gitlab-ci.yml
stages:
  - test
  - deploy-staging
  - deploy-production

test-ansible:
  stage: test
  image: python:3.9
  before_script:
    - pip install ansible molecule[docker]
  script:
    - molecule test
  only:
    - merge_requests

deploy-staging:
  stage: deploy-staging
  image: ansible/ansible:latest
  before_script:
    - echo "$ANSIBLE_VAULT_PASSWORD" > .vault_pass
    - chmod 600 .vault_pass
  script:
    - ansible-playbook -i inventories/staging site.yml --vault-password-file .vault_pass
  environment:
    name: staging
  only:
    - develop

deploy-production:
  stage: deploy-production
  image: ansible/ansible:latest
  before_script:
    - echo "$ANSIBLE_VAULT_PASSWORD" > .vault_pass
    - chmod 600 .vault_pass
  script:
    - ansible-playbook -i inventories/production site.yml --vault-password-file .vault_pass --check
    - ansible-playbook -i inventories/production site.yml --vault-password-file .vault_pass
  environment:
    name: production
  when: manual
  only:
    - main
```

2. **Jenkins Pipeline**
```groovy
// Jenkinsfile
pipeline {
    agent any
    
    environment {
        ANSIBLE_HOST_KEY_CHECKING = 'False'
        ANSIBLE_FORCE_COLOR = 'true'
    }
    
    stages {
        stage('Checkout') {
            steps {
                git 'https://github.com/yourorg/ansible-playbooks.git'
            }
        }
        
        stage('Lint') {
            steps {
                sh 'ansible-lint site.yml'
            }
        }
        
        stage('Test') {
            steps {
                sh 'molecule test'
            }
        }
        
        stage('Deploy to Staging') {
            steps {
                withCredentials([file(credentialsId: 'ansible-vault-key', variable: 'VAULT_KEY')]) {
                    sh 'ansible-playbook -i inventories/staging site.yml --vault-password-file $VAULT_KEY'
                }
            }
        }
        
        stage('Deploy to Production') {
            when {
                branch 'main'
            }
            steps {
                input 'Deploy to production?'
                withCredentials([file(credentialsId: 'ansible-vault-key', variable: 'VAULT_KEY')]) {
                    sh 'ansible-playbook -i inventories/production site.yml --vault-password-file $VAULT_KEY'
                }
            }
        }
    }
    
    post {
        always {
            cleanWs()
        }
    }
}
```

### Exercise
- Set up Ansible in your CI/CD platform
- Implement approval workflows for production deployments
- Create rollback mechanisms

---

## Lab 10: Ansible for Cloud Infrastructure

### Objective
Provision and manage cloud infrastructure using Ansible.

### Steps

1. **AWS Infrastructure Playbook**
```yaml
# aws-infrastructure.yml
---
- name: Provision AWS infrastructure
  hosts: localhost
  gather_facts: no
  vars:
    region: us-west-2
    key_name: my-key-pair
    
  tasks:
    - name: Create VPC
      amazon.aws.ec2_vpc_net:
        name: ansible-vpc
        cidr_block: 10.0.0.0/16
        region: "{{ region }}"
        tags:
          Environment: "{{ env }}"
        state: present
      register: vpc
    
    - name: Create subnet
      amazon.aws.ec2_vpc_subnet:
        vpc_id: "{{ vpc.vpc.id }}"
        cidr: 10.0.1.0/24
        region: "{{ region }}"
        tags:
          Name: ansible-subnet
          Environment: "{{ env }}"
        state: present
      register: subnet
    
    - name: Create security group
      amazon.aws.ec2_group:
        name: ansible-sg
        description: Security group for Ansible managed instances
        vpc_id: "{{ vpc.vpc.id }}"
        region: "{{ region }}"
        rules:
          - proto: tcp
            ports:
              - 22
              - 80
              - 443
            cidr_ip: 0.0.0.0/0
        tags:
          Environment: "{{ env }}"
        state: present
      register: security_group
    
    - name: Launch EC2 instances
      amazon.aws.ec2_instance:
        name: "ansible-instance-{{ item }}"
        image_id: ami-0c02fb55956c7d316  # Amazon Linux 2
        instance_type: t3.micro
        key_name: "{{ key_name }}"
        vpc_subnet_id: "{{ subnet.subnet.id }}"
        security_groups:
          - "{{ security_group.group_id }}"
        tags:
          Environment: "{{ env }}"
          Role: webserver
        state: present
      loop: "{{ range(1, instances_count + 1) | list }}"
      register: instances
```

2. **Azure Infrastructure Playbook**
```yaml
# azure-infrastructure.yml
---
- name: Provision Azure infrastructure
  hosts: localhost
  gather_facts: no
  
  tasks:
    - name: Create resource group
      azure.azcollection.azure_rm_resourcegroup:
        name: "{{ resource_group }}"
        location: "{{ azure_region }}"
        tags:
          Environment: "{{ env }}"
    
    - name: Create virtual network
      azure.azcollection.azure_rm_virtualnetwork:
        resource_group: "{{ resource_group }}"
        name: "{{ vnet_name }}"
        address_prefixes: "10.0.0.0/16"
    
    - name: Create subnet
      azure.azcollection.azure_rm_subnet:
        resource_group: "{{ resource_group }}"
        name: "{{ subnet_name }}"
        address_prefix: "10.0.1.0/24"
        virtual_network: "{{ vnet_name }}"
    
    - name: Create public IP
      azure.azcollection.azure_rm_publicipaddress:
        resource_group: "{{ resource_group }}"
        allocation_method: Static
        name: "{{ vm_name }}-pip"
      register: pip_output
    
    - name: Create Network Security Group
      azure.azcollection.azure_rm_securitygroup:
        resource_group: "{{ resource_group }}"
        name: "{{ vm_name }}-nsg"
        rules:
          - name: SSH
            protocol: Tcp
            destination_port_range: 22
            access: Allow
            priority: 1001
            direction: Inbound
          - name: HTTP
            protocol: Tcp
            destination_port_range: 80
            access: Allow
            priority: 1002
            direction: Inbound
    
    - name: Create virtual machine
      azure.azcollection.azure_rm_virtualmachine:
        resource_group: "{{ resource_group }}"
        name: "{{ vm_name }}"
        vm_size: Standard_B1s
        admin_username: azureuser
        ssh_password_enabled: false
        ssh_public_keys:
          - path: /home/azureuser/.ssh/authorized_keys
            key_data: "{{ ssh_public_key }}"
        image:
          offer: UbuntuServer
          publisher: Canonical
          sku: 18.04-LTS
          version: latest
```

### Exercise
- Create multi-region deployments
- Implement infrastructure scaling playbooks
- Add monitoring and alerting configuration

---

## Best Practices

### 1. Playbook Organization
- Use roles for reusable components
- Separate variables by environment
- Implement proper directory structure
- Use descriptive task names

### 2. Security
- Always use Ansible Vault for secrets
- Implement least privilege access
- Regularly rotate credentials
- Use encrypted connections

### 3. Performance
- Use pipelining for faster execution
- Implement proper fact caching
- Use async tasks for long-running operations
- Optimize inventory management

### 4. Error Handling
- Implement proper error handling
- Use blocks and rescue for complex scenarios
- Add meaningful debug information
- Implement rollback mechanisms

---

## Common Use Cases

1. **Configuration Management**
   - Server configuration standardization
   - Application deployment
   - Security hardening

2. **Infrastructure Provisioning**
   - Cloud resource management
   - Network configuration
   - Storage management

3. **Application Deployment**
   - CI/CD integration
   - Rolling updates
   - Blue-green deployments

4. **Compliance and Security**
   - Security policy enforcement
   - Compliance reporting
   - Vulnerability management

---

## Troubleshooting Guide

### Common Issues
1. **SSH Connection Problems**
   - Verify SSH keys and connectivity
   - Check firewall rules
   - Validate inventory configuration

2. **Permission Issues**
   - Use become for privilege escalation
   - Verify sudo configuration
   - Check file permissions

3. **Module Not Found**
   - Install required collections
   - Update Ansible version
   - Check module documentation

4. **Performance Issues**
   - Enable pipelining
   - Implement fact caching
   - Use async tasks for long operations

---

## Advanced Topics

- Ansible Tower/AWX for enterprise management
- Custom module development
- Plugin development
- Integration with monitoring systems
- Multi-cloud deployments
- Ansible and containers (Docker/Kubernetes)

---

## Resources

- [Ansible Documentation](https://docs.ansible.com/)
- [Ansible Galaxy](https://galaxy.ansible.com/)
- [Molecule Testing](https://molecule.readthedocs.io/)
- [Ansible Lint](https://ansible-lint.readthedocs.io/)
- [Best Practices Guide](https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html)
